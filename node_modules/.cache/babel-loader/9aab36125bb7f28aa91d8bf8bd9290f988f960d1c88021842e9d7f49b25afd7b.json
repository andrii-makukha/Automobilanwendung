{"ast":null,"code":"import { Fragment, isValidElement, cloneElement, createElement, Children } from 'react';\nimport { keyFromSelector } from 'i18next';\nimport HTML from 'html-parse-stringify';\nimport { isObject, isString, warn, warnOnce } from './utils.js';\nimport { getDefaults } from './defaults.js';\nimport { getI18n } from './i18nInstance.js';\nimport { unescape } from './unescape.js';\nconst hasChildren = (node, checkLength) => {\n  if (!node) return false;\n  const base = node.props?.children ?? node.children;\n  if (checkLength) return base.length > 0;\n  return !!base;\n};\nconst getChildren = node => {\n  if (!node) return [];\n  const children = node.props?.children ?? node.children;\n  return node.props?.i18nIsDynamicList ? getAsArray(children) : children;\n};\nconst hasValidReactChildren = children => Array.isArray(children) && children.every(isValidElement);\nconst getAsArray = data => Array.isArray(data) ? data : [data];\nconst mergeProps = (source, target) => {\n  const newTarget = {\n    ...target\n  };\n  newTarget.props = Object.assign(source.props, target.props);\n  return newTarget;\n};\nconst getValuesFromChildren = children => {\n  const values = {};\n  if (!children) return values;\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(values, child);\n    });\n  };\n  getData(children);\n  return values;\n};\nexport const nodesToString = (children, i18nOptions, i18n, i18nKey) => {\n  if (!children) return '';\n  let stringNode = '';\n  const childrenArray = getAsArray(children);\n  const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];\n  childrenArray.forEach((child, childIndex) => {\n    if (isString(child)) {\n      stringNode += `${child}`;\n      return;\n    }\n    if (isValidElement(child)) {\n      const {\n        props,\n        type\n      } = child;\n      const childPropsCount = Object.keys(props).length;\n      const shouldKeepChild = keepArray.indexOf(type) > -1;\n      const childChildren = props.children;\n      if (!childChildren && shouldKeepChild && !childPropsCount) {\n        stringNode += `<${type}/>`;\n        return;\n      }\n      if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {\n        stringNode += `<${childIndex}></${childIndex}>`;\n        return;\n      }\n      if (shouldKeepChild && childPropsCount === 1 && isString(childChildren)) {\n        stringNode += `<${type}>${childChildren}</${type}>`;\n        return;\n      }\n      const content = nodesToString(childChildren, i18nOptions, i18n, i18nKey);\n      stringNode += `<${childIndex}>${content}</${childIndex}>`;\n      return;\n    }\n    if (child === null) {\n      warn(i18n, 'TRANS_NULL_VALUE', `Passed in a null value as child`, {\n        i18nKey\n      });\n      return;\n    }\n    if (isObject(child)) {\n      const {\n        format,\n        ...clone\n      } = child;\n      const keys = Object.keys(clone);\n      if (keys.length === 1) {\n        const value = format ? `${keys[0]}, ${format}` : keys[0];\n        stringNode += `{{${value}}}`;\n        return;\n      }\n      warn(i18n, 'TRANS_INVALID_OBJ', `Invalid child - Object should only have keys {{ value, format }} (format is optional).`, {\n        i18nKey,\n        child\n      });\n      return;\n    }\n    warn(i18n, 'TRANS_INVALID_VAR', `Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.`, {\n      i18nKey,\n      child\n    });\n  });\n  return stringNode;\n};\nconst escapeLiteralLessThan = function (str) {\n  let keepArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let knownComponentsMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!str) return str;\n  const knownNames = Object.keys(knownComponentsMap);\n  const allValidNames = [...keepArray, ...knownNames];\n  let result = '';\n  let i = 0;\n  while (i < str.length) {\n    if (str[i] === '<') {\n      let isValidTag = false;\n      const closingMatch = str.slice(i).match(/^<\\/(\\d+|[a-zA-Z][a-zA-Z0-9-]*)>/);\n      if (closingMatch) {\n        const tagName = closingMatch[1];\n        if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n          isValidTag = true;\n          result += closingMatch[0];\n          i += closingMatch[0].length;\n        }\n      }\n      if (!isValidTag) {\n        const openingMatch = str.slice(i).match(/^<(\\d+|[a-zA-Z][a-zA-Z0-9-]*)(\\s+[\\w-]+(?:=(?:\"[^\"]*\"|'[^']*'|[^\\s>]+))?)*\\s*(\\/)?>/);\n        if (openingMatch) {\n          const tagName = openingMatch[1];\n          if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n            isValidTag = true;\n            result += openingMatch[0];\n            i += openingMatch[0].length;\n          }\n        }\n      }\n      if (!isValidTag) {\n        result += '&lt;';\n        i += 1;\n      }\n    } else {\n      result += str[i];\n      i += 1;\n    }\n  }\n  return result;\n};\nconst renderNodes = (children, knownComponentsMap, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {\n  if (targetString === '') return [];\n  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map(keep => `<${keep}`).join('|')).test(targetString);\n  if (!children && !knownComponentsMap && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];\n  const data = knownComponentsMap ?? {};\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(data, child);\n    });\n  };\n  getData(children);\n  const escapedString = escapeLiteralLessThan(targetString, keepArray, data);\n  const ast = HTML.parse(`<0>${escapedString}</0>`);\n  const opts = {\n    ...data,\n    ...combinedTOpts\n  };\n  const renderInner = (child, node, rootReactNode) => {\n    const childs = getChildren(child);\n    const mappedChildren = mapAST(childs, node.children, rootReactNode);\n    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;\n  };\n  const pushTranslatedJSX = (child, inner, mem, i, isVoid) => {\n    if (child.dummy) {\n      child.children = inner;\n      mem.push(cloneElement(child, {\n        key: i\n      }, isVoid ? undefined : inner));\n    } else {\n      mem.push(...Children.map([child], c => {\n        const INTERNAL_DYNAMIC_MARKER = 'data-i18n-is-dynamic-list';\n        const override = {\n          key: i,\n          [INTERNAL_DYNAMIC_MARKER]: undefined\n        };\n        if (c && c.props) {\n          Object.keys(c.props).forEach(k => {\n            if (k === 'ref' || k === 'children' || k === 'i18nIsDynamicList' || k === INTERNAL_DYNAMIC_MARKER) return;\n            override[k] = c.props[k];\n          });\n        }\n        return cloneElement(c, override, isVoid ? null : inner);\n      }));\n    }\n  };\n  const mapAST = (reactNode, astNode, rootReactNode) => {\n    const reactNodes = getAsArray(reactNode);\n    const astNodes = getAsArray(astNode);\n    return astNodes.reduce((mem, node, i) => {\n      const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);\n      if (node.type === 'tag') {\n        let tmp = reactNodes[parseInt(node.name, 10)];\n        if (!tmp && knownComponentsMap) tmp = knownComponentsMap[node.name];\n        if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];\n        if (!tmp) tmp = {};\n        const props = {\n          ...node.attrs\n        };\n        if (shouldUnescape) {\n          Object.keys(props).forEach(p => {\n            const val = props[p];\n            if (isString(val)) {\n              props[p] = unescape(val);\n            }\n          });\n        }\n        const child = Object.keys(props).length !== 0 ? mergeProps({\n          props\n        }, tmp) : tmp;\n        const isElement = isValidElement(child);\n        const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;\n        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && isObject(child) && child.dummy && !isElement;\n        const isKnownComponent = isObject(knownComponentsMap) && Object.hasOwnProperty.call(knownComponentsMap, node.name);\n        if (isString(child)) {\n          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);\n          mem.push(value);\n        } else if (hasChildren(child) || isValidTranslationWithChildren) {\n          const inner = renderInner(child, node, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (isEmptyTransWithHTML) {\n          const inner = mapAST(reactNodes, node.children, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (isKnownComponent) {\n            const inner = renderInner(child, node, rootReactNode);\n            pushTranslatedJSX(child, inner, mem, i, node.voidElement);\n          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }));\n            } else {\n              const inner = mapAST(reactNodes, node.children, rootReactNode);\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }, inner));\n            }\n          } else if (node.voidElement) {\n            mem.push(`<${node.name} />`);\n          } else {\n            const inner = mapAST(reactNodes, node.children, rootReactNode);\n            mem.push(`<${node.name}>${inner}</${node.name}>`);\n          }\n        } else if (isObject(child) && !isElement) {\n          const content = node.children[0] ? translationContent : null;\n          if (content) mem.push(content);\n        } else {\n          pushTranslatedJSX(child, translationContent, mem, i, node.children.length !== 1 || !translationContent);\n        }\n      } else if (node.type === 'text') {\n        const wrapTextNodes = i18nOptions.transWrapTextNodes;\n        const unescapeFn = typeof i18nOptions.unescape === 'function' ? i18nOptions.unescape : getDefaults().unescape;\n        const content = shouldUnescape ? unescapeFn(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);\n        if (wrapTextNodes) {\n          mem.push(createElement(wrapTextNodes, {\n            key: `${node.name}-${i}`\n          }, content));\n        } else {\n          mem.push(content);\n        }\n      }\n      return mem;\n    }, []);\n  };\n  const result = mapAST([{\n    dummy: true,\n    children: children || []\n  }], ast, getAsArray(children || []));\n  return getChildren(result[0]);\n};\nconst fixComponentProps = (component, index, translation) => {\n  const componentKey = component.key || index;\n  const comp = cloneElement(component, {\n    key: componentKey\n  });\n  if (!comp.props || !comp.props.children || translation.indexOf(`${index}/>`) < 0 && translation.indexOf(`${index} />`) < 0) {\n    return comp;\n  }\n  function Componentized() {\n    return createElement(Fragment, null, comp);\n  }\n  return createElement(Componentized, {\n    key: componentKey\n  });\n};\nconst generateArrayComponents = (components, translation) => components.map((c, index) => fixComponentProps(c, index, translation));\nconst generateObjectComponents = (components, translation) => {\n  const componentMap = {};\n  Object.keys(components).forEach(c => {\n    Object.assign(componentMap, {\n      [c]: fixComponentProps(components[c], c, translation)\n    });\n  });\n  return componentMap;\n};\nconst generateComponents = (components, translation, i18n, i18nKey) => {\n  if (!components) return null;\n  if (Array.isArray(components)) {\n    return generateArrayComponents(components, translation);\n  }\n  if (isObject(components)) {\n    return generateObjectComponents(components, translation);\n  }\n  warnOnce(i18n, 'TRANS_INVALID_COMPONENTS', `<Trans /> \"components\" prop expects an object or array`, {\n    i18nKey\n  });\n  return null;\n};\nconst isComponentsMap = object => {\n  if (!isObject(object)) return false;\n  if (Array.isArray(object)) return false;\n  return Object.keys(object).reduce((acc, key) => acc && Number.isNaN(Number.parseFloat(key)), true);\n};\nexport function Trans(_ref) {\n  let {\n    children,\n    count,\n    parent,\n    i18nKey,\n    context,\n    tOptions = {},\n    values,\n    defaults,\n    components,\n    ns,\n    i18n: i18nFromProps,\n    t: tFromProps,\n    shouldUnescape,\n    ...additionalProps\n  } = _ref;\n  const i18n = i18nFromProps || getI18n();\n  if (!i18n) {\n    warnOnce(i18n, 'NO_I18NEXT_INSTANCE', `Trans: You need to pass in an i18next instance using i18nextReactModule`, {\n      i18nKey\n    });\n    return children;\n  }\n  const t = tFromProps || i18n.t.bind(i18n) || (k => k);\n  const reactI18nextOptions = {\n    ...getDefaults(),\n    ...i18n.options?.react\n  };\n  let namespaces = ns || t.ns || i18n.options?.defaultNS;\n  namespaces = isString(namespaces) ? [namespaces] : namespaces || ['translation'];\n  const {\n    transDefaultProps\n  } = reactI18nextOptions;\n  const mergedTOptions = transDefaultProps?.tOptions ? {\n    ...transDefaultProps.tOptions,\n    ...tOptions\n  } : tOptions;\n  const mergedShouldUnescape = shouldUnescape ?? transDefaultProps?.shouldUnescape;\n  const mergedValues = transDefaultProps?.values ? {\n    ...transDefaultProps.values,\n    ...values\n  } : values;\n  const mergedComponents = transDefaultProps?.components ? {\n    ...transDefaultProps.components,\n    ...components\n  } : components;\n  const nodeAsString = nodesToString(children, reactI18nextOptions, i18n, i18nKey);\n  const defaultValue = defaults || mergedTOptions?.defaultValue || nodeAsString || reactI18nextOptions.transEmptyNodeValue || (typeof i18nKey === 'function' ? keyFromSelector(i18nKey) : i18nKey);\n  const {\n    hashTransKey\n  } = reactI18nextOptions;\n  const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);\n  if (i18n.options?.interpolation?.defaultVariables) {\n    values = mergedValues && Object.keys(mergedValues).length > 0 ? {\n      ...mergedValues,\n      ...i18n.options.interpolation.defaultVariables\n    } : {\n      ...i18n.options.interpolation.defaultVariables\n    };\n  } else {\n    values = mergedValues;\n  }\n  const valuesFromChildren = getValuesFromChildren(children);\n  if (valuesFromChildren && typeof valuesFromChildren.count === 'number' && count === undefined) {\n    count = valuesFromChildren.count;\n  }\n  const interpolationOverride = values || count !== undefined && !i18n.options?.interpolation?.alwaysFormat || !children ? mergedTOptions.interpolation : {\n    interpolation: {\n      ...mergedTOptions.interpolation,\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n  const combinedTOpts = {\n    ...mergedTOptions,\n    context: context || mergedTOptions.context,\n    count,\n    ...values,\n    ...interpolationOverride,\n    defaultValue,\n    ns: namespaces\n  };\n  let translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (translation === key && defaultValue) translation = defaultValue;\n  const generatedComponents = generateComponents(mergedComponents, translation, i18n, i18nKey);\n  let indexedChildren = generatedComponents || children;\n  let componentsMap = null;\n  if (isComponentsMap(generatedComponents)) {\n    componentsMap = generatedComponents;\n    indexedChildren = children;\n  }\n  const content = renderNodes(indexedChildren, componentsMap, translation, i18n, reactI18nextOptions, combinedTOpts, mergedShouldUnescape);\n  const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;\n  return useAsParent ? createElement(useAsParent, additionalProps, content) : content;\n}","map":{"version":3,"names":["Fragment","isValidElement","cloneElement","createElement","Children","keyFromSelector","HTML","isObject","isString","warn","warnOnce","getDefaults","getI18n","unescape","hasChildren","node","checkLength","base","props","children","length","getChildren","i18nIsDynamicList","getAsArray","hasValidReactChildren","Array","isArray","every","data","mergeProps","source","target","newTarget","Object","assign","getValuesFromChildren","values","getData","childs","childrenArray","forEach","child","nodesToString","i18nOptions","i18n","i18nKey","stringNode","keepArray","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","childIndex","type","childPropsCount","keys","shouldKeepChild","indexOf","childChildren","content","format","clone","value","escapeLiteralLessThan","str","arguments","undefined","knownComponentsMap","knownNames","allValidNames","result","i","isValidTag","closingMatch","slice","match","tagName","test","includes","openingMatch","renderNodes","targetString","combinedTOpts","shouldUnescape","emptyChildrenButNeedsHandling","RegExp","map","keep","join","escapedString","ast","parse","opts","renderInner","rootReactNode","mappedChildren","mapAST","pushTranslatedJSX","inner","mem","isVoid","dummy","push","key","c","INTERNAL_DYNAMIC_MARKER","override","k","reactNode","astNode","reactNodes","astNodes","reduce","translationContent","services","interpolator","interpolate","language","tmp","parseInt","name","attrs","p","val","isElement","isValidTranslationWithChildren","voidElement","isEmptyTransWithHTML","isKnownComponent","hasOwnProperty","call","Number","isNaN","parseFloat","wrapTextNodes","transWrapTextNodes","unescapeFn","fixComponentProps","component","index","translation","componentKey","comp","Componentized","generateArrayComponents","components","generateObjectComponents","componentMap","generateComponents","isComponentsMap","object","acc","Trans","_ref","count","parent","context","tOptions","defaults","ns","i18nFromProps","t","tFromProps","additionalProps","bind","reactI18nextOptions","options","react","namespaces","defaultNS","transDefaultProps","mergedTOptions","mergedShouldUnescape","mergedValues","mergedComponents","nodeAsString","defaultValue","transEmptyNodeValue","hashTransKey","interpolation","defaultVariables","valuesFromChildren","interpolationOverride","alwaysFormat","prefix","suffix","generatedComponents","indexedChildren","componentsMap","useAsParent","defaultTransParent"],"sources":["/Users/andriimakukha/Hillel/lesson-46/node_modules/react-i18next/dist/es/TransWithoutContext.js"],"sourcesContent":["import { Fragment, isValidElement, cloneElement, createElement, Children } from 'react';\nimport { keyFromSelector } from 'i18next';\nimport HTML from 'html-parse-stringify';\nimport { isObject, isString, warn, warnOnce } from './utils.js';\nimport { getDefaults } from './defaults.js';\nimport { getI18n } from './i18nInstance.js';\nimport { unescape } from './unescape.js';\nconst hasChildren = (node, checkLength) => {\n  if (!node) return false;\n  const base = node.props?.children ?? node.children;\n  if (checkLength) return base.length > 0;\n  return !!base;\n};\nconst getChildren = node => {\n  if (!node) return [];\n  const children = node.props?.children ?? node.children;\n  return node.props?.i18nIsDynamicList ? getAsArray(children) : children;\n};\nconst hasValidReactChildren = children => Array.isArray(children) && children.every(isValidElement);\nconst getAsArray = data => Array.isArray(data) ? data : [data];\nconst mergeProps = (source, target) => {\n  const newTarget = {\n    ...target\n  };\n  newTarget.props = Object.assign(source.props, target.props);\n  return newTarget;\n};\nconst getValuesFromChildren = children => {\n  const values = {};\n  if (!children) return values;\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(values, child);\n    });\n  };\n  getData(children);\n  return values;\n};\nexport const nodesToString = (children, i18nOptions, i18n, i18nKey) => {\n  if (!children) return '';\n  let stringNode = '';\n  const childrenArray = getAsArray(children);\n  const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];\n  childrenArray.forEach((child, childIndex) => {\n    if (isString(child)) {\n      stringNode += `${child}`;\n      return;\n    }\n    if (isValidElement(child)) {\n      const {\n        props,\n        type\n      } = child;\n      const childPropsCount = Object.keys(props).length;\n      const shouldKeepChild = keepArray.indexOf(type) > -1;\n      const childChildren = props.children;\n      if (!childChildren && shouldKeepChild && !childPropsCount) {\n        stringNode += `<${type}/>`;\n        return;\n      }\n      if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {\n        stringNode += `<${childIndex}></${childIndex}>`;\n        return;\n      }\n      if (shouldKeepChild && childPropsCount === 1 && isString(childChildren)) {\n        stringNode += `<${type}>${childChildren}</${type}>`;\n        return;\n      }\n      const content = nodesToString(childChildren, i18nOptions, i18n, i18nKey);\n      stringNode += `<${childIndex}>${content}</${childIndex}>`;\n      return;\n    }\n    if (child === null) {\n      warn(i18n, 'TRANS_NULL_VALUE', `Passed in a null value as child`, {\n        i18nKey\n      });\n      return;\n    }\n    if (isObject(child)) {\n      const {\n        format,\n        ...clone\n      } = child;\n      const keys = Object.keys(clone);\n      if (keys.length === 1) {\n        const value = format ? `${keys[0]}, ${format}` : keys[0];\n        stringNode += `{{${value}}}`;\n        return;\n      }\n      warn(i18n, 'TRANS_INVALID_OBJ', `Invalid child - Object should only have keys {{ value, format }} (format is optional).`, {\n        i18nKey,\n        child\n      });\n      return;\n    }\n    warn(i18n, 'TRANS_INVALID_VAR', `Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.`, {\n      i18nKey,\n      child\n    });\n  });\n  return stringNode;\n};\nconst escapeLiteralLessThan = (str, keepArray = [], knownComponentsMap = {}) => {\n  if (!str) return str;\n  const knownNames = Object.keys(knownComponentsMap);\n  const allValidNames = [...keepArray, ...knownNames];\n  let result = '';\n  let i = 0;\n  while (i < str.length) {\n    if (str[i] === '<') {\n      let isValidTag = false;\n      const closingMatch = str.slice(i).match(/^<\\/(\\d+|[a-zA-Z][a-zA-Z0-9-]*)>/);\n      if (closingMatch) {\n        const tagName = closingMatch[1];\n        if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n          isValidTag = true;\n          result += closingMatch[0];\n          i += closingMatch[0].length;\n        }\n      }\n      if (!isValidTag) {\n        const openingMatch = str.slice(i).match(/^<(\\d+|[a-zA-Z][a-zA-Z0-9-]*)(\\s+[\\w-]+(?:=(?:\"[^\"]*\"|'[^']*'|[^\\s>]+))?)*\\s*(\\/)?>/);\n        if (openingMatch) {\n          const tagName = openingMatch[1];\n          if (/^\\d+$/.test(tagName) || allValidNames.includes(tagName)) {\n            isValidTag = true;\n            result += openingMatch[0];\n            i += openingMatch[0].length;\n          }\n        }\n      }\n      if (!isValidTag) {\n        result += '&lt;';\n        i += 1;\n      }\n    } else {\n      result += str[i];\n      i += 1;\n    }\n  }\n  return result;\n};\nconst renderNodes = (children, knownComponentsMap, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {\n  if (targetString === '') return [];\n  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map(keep => `<${keep}`).join('|')).test(targetString);\n  if (!children && !knownComponentsMap && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];\n  const data = knownComponentsMap ?? {};\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if (isString(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if (isObject(child) && !isValidElement(child)) Object.assign(data, child);\n    });\n  };\n  getData(children);\n  const escapedString = escapeLiteralLessThan(targetString, keepArray, data);\n  const ast = HTML.parse(`<0>${escapedString}</0>`);\n  const opts = {\n    ...data,\n    ...combinedTOpts\n  };\n  const renderInner = (child, node, rootReactNode) => {\n    const childs = getChildren(child);\n    const mappedChildren = mapAST(childs, node.children, rootReactNode);\n    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;\n  };\n  const pushTranslatedJSX = (child, inner, mem, i, isVoid) => {\n    if (child.dummy) {\n      child.children = inner;\n      mem.push(cloneElement(child, {\n        key: i\n      }, isVoid ? undefined : inner));\n    } else {\n      mem.push(...Children.map([child], c => {\n        const INTERNAL_DYNAMIC_MARKER = 'data-i18n-is-dynamic-list';\n        const override = {\n          key: i,\n          [INTERNAL_DYNAMIC_MARKER]: undefined\n        };\n        if (c && c.props) {\n          Object.keys(c.props).forEach(k => {\n            if (k === 'ref' || k === 'children' || k === 'i18nIsDynamicList' || k === INTERNAL_DYNAMIC_MARKER) return;\n            override[k] = c.props[k];\n          });\n        }\n        return cloneElement(c, override, isVoid ? null : inner);\n      }));\n    }\n  };\n  const mapAST = (reactNode, astNode, rootReactNode) => {\n    const reactNodes = getAsArray(reactNode);\n    const astNodes = getAsArray(astNode);\n    return astNodes.reduce((mem, node, i) => {\n      const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);\n      if (node.type === 'tag') {\n        let tmp = reactNodes[parseInt(node.name, 10)];\n        if (!tmp && knownComponentsMap) tmp = knownComponentsMap[node.name];\n        if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];\n        if (!tmp) tmp = {};\n        const props = {\n          ...node.attrs\n        };\n        if (shouldUnescape) {\n          Object.keys(props).forEach(p => {\n            const val = props[p];\n            if (isString(val)) {\n              props[p] = unescape(val);\n            }\n          });\n        }\n        const child = Object.keys(props).length !== 0 ? mergeProps({\n          props\n        }, tmp) : tmp;\n        const isElement = isValidElement(child);\n        const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;\n        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && isObject(child) && child.dummy && !isElement;\n        const isKnownComponent = isObject(knownComponentsMap) && Object.hasOwnProperty.call(knownComponentsMap, node.name);\n        if (isString(child)) {\n          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);\n          mem.push(value);\n        } else if (hasChildren(child) || isValidTranslationWithChildren) {\n          const inner = renderInner(child, node, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (isEmptyTransWithHTML) {\n          const inner = mapAST(reactNodes, node.children, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (isKnownComponent) {\n            const inner = renderInner(child, node, rootReactNode);\n            pushTranslatedJSX(child, inner, mem, i, node.voidElement);\n          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }));\n            } else {\n              const inner = mapAST(reactNodes, node.children, rootReactNode);\n              mem.push(createElement(node.name, {\n                key: `${node.name}-${i}`\n              }, inner));\n            }\n          } else if (node.voidElement) {\n            mem.push(`<${node.name} />`);\n          } else {\n            const inner = mapAST(reactNodes, node.children, rootReactNode);\n            mem.push(`<${node.name}>${inner}</${node.name}>`);\n          }\n        } else if (isObject(child) && !isElement) {\n          const content = node.children[0] ? translationContent : null;\n          if (content) mem.push(content);\n        } else {\n          pushTranslatedJSX(child, translationContent, mem, i, node.children.length !== 1 || !translationContent);\n        }\n      } else if (node.type === 'text') {\n        const wrapTextNodes = i18nOptions.transWrapTextNodes;\n        const unescapeFn = typeof i18nOptions.unescape === 'function' ? i18nOptions.unescape : getDefaults().unescape;\n        const content = shouldUnescape ? unescapeFn(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);\n        if (wrapTextNodes) {\n          mem.push(createElement(wrapTextNodes, {\n            key: `${node.name}-${i}`\n          }, content));\n        } else {\n          mem.push(content);\n        }\n      }\n      return mem;\n    }, []);\n  };\n  const result = mapAST([{\n    dummy: true,\n    children: children || []\n  }], ast, getAsArray(children || []));\n  return getChildren(result[0]);\n};\nconst fixComponentProps = (component, index, translation) => {\n  const componentKey = component.key || index;\n  const comp = cloneElement(component, {\n    key: componentKey\n  });\n  if (!comp.props || !comp.props.children || translation.indexOf(`${index}/>`) < 0 && translation.indexOf(`${index} />`) < 0) {\n    return comp;\n  }\n  function Componentized() {\n    return createElement(Fragment, null, comp);\n  }\n  return createElement(Componentized, {\n    key: componentKey\n  });\n};\nconst generateArrayComponents = (components, translation) => components.map((c, index) => fixComponentProps(c, index, translation));\nconst generateObjectComponents = (components, translation) => {\n  const componentMap = {};\n  Object.keys(components).forEach(c => {\n    Object.assign(componentMap, {\n      [c]: fixComponentProps(components[c], c, translation)\n    });\n  });\n  return componentMap;\n};\nconst generateComponents = (components, translation, i18n, i18nKey) => {\n  if (!components) return null;\n  if (Array.isArray(components)) {\n    return generateArrayComponents(components, translation);\n  }\n  if (isObject(components)) {\n    return generateObjectComponents(components, translation);\n  }\n  warnOnce(i18n, 'TRANS_INVALID_COMPONENTS', `<Trans /> \"components\" prop expects an object or array`, {\n    i18nKey\n  });\n  return null;\n};\nconst isComponentsMap = object => {\n  if (!isObject(object)) return false;\n  if (Array.isArray(object)) return false;\n  return Object.keys(object).reduce((acc, key) => acc && Number.isNaN(Number.parseFloat(key)), true);\n};\nexport function Trans({\n  children,\n  count,\n  parent,\n  i18nKey,\n  context,\n  tOptions = {},\n  values,\n  defaults,\n  components,\n  ns,\n  i18n: i18nFromProps,\n  t: tFromProps,\n  shouldUnescape,\n  ...additionalProps\n}) {\n  const i18n = i18nFromProps || getI18n();\n  if (!i18n) {\n    warnOnce(i18n, 'NO_I18NEXT_INSTANCE', `Trans: You need to pass in an i18next instance using i18nextReactModule`, {\n      i18nKey\n    });\n    return children;\n  }\n  const t = tFromProps || i18n.t.bind(i18n) || (k => k);\n  const reactI18nextOptions = {\n    ...getDefaults(),\n    ...i18n.options?.react\n  };\n  let namespaces = ns || t.ns || i18n.options?.defaultNS;\n  namespaces = isString(namespaces) ? [namespaces] : namespaces || ['translation'];\n  const {\n    transDefaultProps\n  } = reactI18nextOptions;\n  const mergedTOptions = transDefaultProps?.tOptions ? {\n    ...transDefaultProps.tOptions,\n    ...tOptions\n  } : tOptions;\n  const mergedShouldUnescape = shouldUnescape ?? transDefaultProps?.shouldUnescape;\n  const mergedValues = transDefaultProps?.values ? {\n    ...transDefaultProps.values,\n    ...values\n  } : values;\n  const mergedComponents = transDefaultProps?.components ? {\n    ...transDefaultProps.components,\n    ...components\n  } : components;\n  const nodeAsString = nodesToString(children, reactI18nextOptions, i18n, i18nKey);\n  const defaultValue = defaults || mergedTOptions?.defaultValue || nodeAsString || reactI18nextOptions.transEmptyNodeValue || (typeof i18nKey === 'function' ? keyFromSelector(i18nKey) : i18nKey);\n  const {\n    hashTransKey\n  } = reactI18nextOptions;\n  const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);\n  if (i18n.options?.interpolation?.defaultVariables) {\n    values = mergedValues && Object.keys(mergedValues).length > 0 ? {\n      ...mergedValues,\n      ...i18n.options.interpolation.defaultVariables\n    } : {\n      ...i18n.options.interpolation.defaultVariables\n    };\n  } else {\n    values = mergedValues;\n  }\n  const valuesFromChildren = getValuesFromChildren(children);\n  if (valuesFromChildren && typeof valuesFromChildren.count === 'number' && count === undefined) {\n    count = valuesFromChildren.count;\n  }\n  const interpolationOverride = values || count !== undefined && !i18n.options?.interpolation?.alwaysFormat || !children ? mergedTOptions.interpolation : {\n    interpolation: {\n      ...mergedTOptions.interpolation,\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n  const combinedTOpts = {\n    ...mergedTOptions,\n    context: context || mergedTOptions.context,\n    count,\n    ...values,\n    ...interpolationOverride,\n    defaultValue,\n    ns: namespaces\n  };\n  let translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (translation === key && defaultValue) translation = defaultValue;\n  const generatedComponents = generateComponents(mergedComponents, translation, i18n, i18nKey);\n  let indexedChildren = generatedComponents || children;\n  let componentsMap = null;\n  if (isComponentsMap(generatedComponents)) {\n    componentsMap = generatedComponents;\n    indexedChildren = children;\n  }\n  const content = renderNodes(indexedChildren, componentsMap, translation, i18n, reactI18nextOptions, combinedTOpts, mergedShouldUnescape);\n  const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;\n  return useAsParent ? createElement(useAsParent, additionalProps, content) : content;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}